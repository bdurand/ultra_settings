# frozen_string_literal: true

module UltraSettings
  module Tasks
    class Documentation
      def initialize(config_class)
        @config_class = config_class
      end

      # Add YARD documentation comments to the source files for the configuration's fields.
      #
      # @return [Hash<String, String>] A hash mapping source file paths to their updated content.
      def sources_with_yard_docs
        sources = {}
        source_fields = {}

        defined_fields.each do |field|
          path, _line = field_location(field)
          sources[path] ||= File.read(path)
          source_fields[path] ||= []
          source_fields[path] << field
        end

        sources.to_h do |path, content|
          fields = source_fields[path]

          # Generate the YARD docs as a separate class definition
          yard_class = generate_yard_class(fields)

          # Remove existing YARD docs between markers if present
          content_without_docs = remove_existing_yard_docs(content)

          # Append the YARD class definition to the end of the file
          [path, content_without_docs.rstrip + "\n\n" + yard_class]
        end
      end

      # Add RBS type signatures to RBS files for the configuration's fields.
      #
      # @return [Hash<String, String>] A hash mapping RBS file paths to their content.
      def rbs_sources
        sources = {}
        source_fields = {}

        defined_fields.each do |field|
          path, _line = field_location(field)
          rbs_path = path.sub(/\.rb$/, ".rbs")
          sources[rbs_path] ||= ""
          source_fields[rbs_path] ||= []
          source_fields[rbs_path] << field
        end

        sources.to_h do |rbs_path, _content|
          fields = source_fields[rbs_path]

          # Generate the RBS class definition
          [rbs_path, generate_rbs_class(fields)]
        end
      end

      def source_with_sorbet
      end

      def field_location(field)
        method_name = field.name
        method_name = "#{method_name}?" if field.type == :boolean
        config_class.instance_method(method_name).source_location
      end

      def defined_fields
        local_fields = config_class.fields
        if config_class.superclass < Configuration
          local_fields -= config_class.superclass.fields
        end
        local_fields
      end

      def yard_doc(field)
        return_type = yard_type_for_field(field)
        <<~YARD
          # @!attribute [r] #{field.name}
          # @return [#{return_type}]
        YARD
      end

      private

      attr_reader :config_class

      def generate_yard_class(fields)
        class_name = config_class.name

        yard_lines = ["# Begin autogenerated YARD docs"]
        yard_lines << "class #{class_name}"

        fields.each_with_index do |field, index|
          yard_doc(field).lines.each do |doc_line|
            yard_lines << "  #{doc_line.rstrip}"
          end
          # Add blank line between fields, but not after the last one
          yard_lines << "" if index < fields.size - 1
        end

        yard_lines << "end"
        yard_lines << "# End autogenerated YARD docs"

        yard_lines.join("\n") + "\n"
      end

      def remove_existing_yard_docs(content)
        # Remove content between the autogenerated markers (inclusive)
        content.gsub(/^# Begin autogenerated YARD docs\n.*?^# End autogenerated YARD docs\n/m, "")
      end

      def generate_rbs_class(fields)
        class_name = config_class.name

        rbs_lines = ["# Begin autogenerated RBS type signatures"]
        rbs_lines << "class #{class_name}"

        fields.each do |field|
          method_name = field.name
          return_type = rbs_type_for_field(field)
          rbs_lines << "  def #{method_name}: () -> #{return_type}"

          # Add predicate method for boolean fields
          if field.type == :boolean
            rbs_lines << "  def #{method_name}?: () -> bool"
          end
        end

        rbs_lines << "end"
        rbs_lines << "# End autogenerated RBS type signatures"

        rbs_lines.join("\n") + "\n"
      end

      def rbs_type_for_field(field)
        base_type = case field.type
        when :string
          "String"
        when :symbol
          "Symbol"
        when :integer
          "Integer"
        when :float
          "Float"
        when :boolean
          "bool"
        when :datetime
          "Time"
        when :array
          "Array[String]"
        else
          "untyped"
        end

        # Boolean fields always return a value (true or false), never nil
        # Fields with default values never return nil UNLESS they have a default_if condition
        # which can prevent the default from being applied
        if field.type == :boolean || (!field.default.nil? && field.default_if.nil?)
          base_type
        else
          "#{base_type}?"
        end
      end

      def yard_type_for_field(field)
        base_type = case field.type
        when :string
          "String"
        when :symbol
          "Symbol"
        when :integer
          "Integer"
        when :float
          "Float"
        when :boolean
          "Boolean"
        when :datetime
          "Time"
        when :array
          "Array<String>"
        else
          "Object"
        end

        # Boolean fields always return a value (true or false), never nil
        # Fields with default values never return nil UNLESS they have a default_if condition
        # which can prevent the default from being applied
        if field.type == :boolean || (!field.default.nil? && field.default_if.nil?)
          base_type
        else
          "#{base_type}, nil"
        end
      end
    end
  end
end
