# frozen_string_literal: true

module UltraSettings
  module Tasks
    class Documentation
      # Create a new documentation generator for a configuration class.
      #
      # @param config_class [Class] The configuration class to generate documentation for
      def initialize(config_class)
        @config_class = config_class
      end

      # Add YARD documentation comments to the source files for the configuration's fields.
      # Generates YARD attribute documentation for each field and appends it to the source file
      # between autogenerated markers.
      #
      # @return [Hash<String, String>] A hash mapping source file paths to their updated content
      def sources_with_yard_docs
        sources = {}
        source_fields = {}

        defined_fields.each do |field|
          path, _line = field_location(field)
          sources[path] ||= File.read(path)
          source_fields[path] ||= []
          source_fields[path] << field
        end

        sources.collect do |path, content|
          fields = source_fields[path]

          # Generate the YARD docs as a separate class definition
          yard_class = generate_yard_class(fields)

          # Remove existing YARD docs between markers if present
          content_without_docs = remove_existing_yard_docs(content)

          # Append the YARD class definition to the end of the file
          [path, content_without_docs.rstrip + "\n\n" + yard_class]
        end.to_h
      end

      # Get the source file path and line number where a field's accessor method is defined.
      #
      # @param field [UltraSettings::Field] The field to locate
      # @return [Array<(String, Integer)>] A tuple of file path and line number
      def field_location(field)
        method_name = field.name
        method_name = "#{method_name}?" if field.type == :boolean
        config_class.instance_method(method_name).source_location
      end

      # Get the list of fields defined directly on this configuration class (excluding inherited fields).
      #
      # @return [Array<UltraSettings::Field>] The fields defined on this class
      def defined_fields
        local_fields = config_class.fields
        if config_class.superclass < Configuration
          local_fields -= config_class.superclass.fields
        end
        local_fields
      end

      # Generate YARD documentation comment for a single field.
      #
      # @param field [UltraSettings::Field] The field to document
      # @return [String] The YARD comment text
      def yard_doc(field)
        return_type = yard_type_for_field(field)
        <<~YARD
          # @!attribute [r] #{field.name}
          # @return [#{return_type}]
        YARD
      end

      private

      attr_reader :config_class

      def generate_yard_class(fields)
        class_name = config_class.name

        yard_lines = ["# Begin autogenerated YARD docs"]
        yard_lines << "class #{class_name}"

        fields.each_with_index do |field, index|
          yard_doc(field).lines.each do |doc_line|
            yard_lines << "  #{doc_line.rstrip}"
          end
          # Add blank line between fields, but not after the last one
          yard_lines << "" if index < fields.size - 1
        end

        yard_lines << "end"
        yard_lines << "# End autogenerated YARD docs"

        yard_lines.join("\n") + "\n"
      end

      def remove_existing_yard_docs(content)
        # Remove content between the autogenerated markers (inclusive)
        content.gsub(/^# Begin autogenerated YARD docs\n.*?^# End autogenerated YARD docs\n/m, "")
      end

      def yard_type_for_field(field)
        base_type = case field.type
        when :string
          "String"
        when :symbol
          "Symbol"
        when :integer
          "Integer"
        when :float
          "Float"
        when :boolean
          "Boolean"
        when :datetime
          "Time"
        when :array
          "Array<String>"
        else
          "Object"
        end

        # Boolean fields always return a value (true or false), never nil
        # Fields with default values never return nil UNLESS they have a default_if condition
        # which can prevent the default from being applied
        if field.type == :boolean || (!field.default.nil? && field.default_if.nil?)
          base_type
        else
          "#{base_type}, nil"
        end
      end
    end
  end
end
